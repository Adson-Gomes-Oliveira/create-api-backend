/// <reference types="node" />
import { AppendOptions } from '../types';
import { LockOptions, UnlockOptions, CheckOptions } from 'proper-lockfile';
import { Stats, SymlinkType, CopyOptions, WriteFileOptions, MoveOptions } from 'fs-extra';
export declare class Filesystem {
    /**
     * Retrieve information about the given file. Use `access`
     * to check whether the `file` exists instead of `stat`.
     *
     * @param {String} file
     *
     * @returns {Stats}
     */
    static stat(file: string): Promise<Stats>;
    /**
     * Returns the file size in bytes of the file located at `path`.
     *
     * @param {String} path
     *
     * @returns {Integer}
     */
    static size(path: string): Promise<number>;
    /**
     * Retrieve the time when `file` was last modified.
     *
     * @param {String} file
     *
     * @returns {Date}
     */
    static lastModified(file: string): Promise<Date>;
    /**
     * Retrieve the time when `file` was last accessed.
     *
     * @param {String} file
     *
     * @returns {Date}
     */
    static lastAccessed(file: string): Promise<Date>;
    /**
     * Change the file system timestamps of the
     * referenced `path`. Updates the last
     * accessed and last modified properties.
     *
     * @param {String} path
     * @param {Number} lastAccessed
     * @param {Number} lastModified
     *
     * @throws
     */
    static updateTimestamps(path: string, lastAccessed: Date, lastModified: Date): Promise<void>;
    /**
     * Test the user's permissions for the given `path` which can
     * be a file or directory. The `mode` argument is an optional
     * integer to specify the accessibility level.
     *
     * @param {String} path  - file or directory path
     * @param {Integer} mode - defaults to `fs.constants.F_OK`
     *
     * @returns {Boolean}
     *
     * @throws
     */
    static canAccess(path: string, mode?: number): Promise<boolean>;
    /**
     * Determines whether the given `path` exists on the file system.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    static pathExists(path: string): Promise<boolean>;
    /**
     * Shortcut for `pathExists` to check whether a given file
     * or directory exists on the file system.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    static exists(path: string): Promise<boolean>;
    /**
     * Determines wether the given `path` does not exists.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    static notExists(path: string): Promise<boolean>;
    /**
     * Updates the access and modification times of the given `file` current
     * time. This method creates the `file` if it doesn’t exist.
     *
     * @param {String} file
     */
    static touch(file: string): Promise<void>;
    /**
     * Ensure that the `file` exists. If the requested file and
     * directories do not exist, they are created. If the file
     * already exists, it is NOT modified.
     *
     * @param {String} file
     */
    static ensureFile(file: string): Promise<void>;
    /**
     * Read the entire content of `file`. If no `encoding` is
     * specified, the raw buffer is returned. If `encoding` is
     * an object, it allows the `encoding` and `flag` options.
     *
     * @param {String} file
     * @param {String|Object} encoding
     *
     * @returns {String}
     */
    static readFile(file: string, encoding?: string): Promise<string>;
    /**
     * Read the contents of a directory with the given `path`.
     * Returns an array of the names of the files in the
     * directory excluding `.` and `..`.
     *
     * @param {String} path
     *
     * @returns {Array}
     */
    static files(path: string): Promise<string[]>;
    /**
     * Read the contents of the directory at the given `path`
     * recursively. Returns an array of file names
     * excluding `.`, `..`, and dotfiles.
     *
     * @param {String} path
     * @param {Object} options config object - supports the `ignore` property: list of ignored files
     *
     * @returns {Array}
     */
    static allFiles(path: string, options?: any): Promise<string[]>;
    /**
     * Write the given `content` to the file` and create
     * any parent directories if not existent.
     *
     * @param  {String} path
     * @param  {String} content
     * @param  {Object} options
     */
    static writeFile(file: string, content: string, options: WriteFileOptions): Promise<void>;
    /**
     * Removes a file or directory from the file system located at `path`.
     *
     * @param {String} path
     */
    static remove(path: string): Promise<void>;
    /**
     * Removes a `file` from the file system.
     *
     * @param {String} file
     */
    static removeFile(file: string): Promise<void>;
    /**
     * Copy a file or directory from `src` to `dest`. The
     * directory can have contents. Like `cp -r`. If
     * `src` is a directory this method copies everything
     * inside of `src`, not the entire directory itself.
     *
     * If `src` is a file, make sure that `dest` is a file
     * as well (and not a directory).
     *
     * @param {String} src  - source path
     * @param {String} dest - destination path
     * @param {Object} options
     */
    static copy(src: string, dest: string, options: CopyOptions): Promise<void>;
    /**
     * Moves a file or directory from `src` to `dest`. By default,
     * this method doesn't override existingfiles. You can
     * override existing files using `{ override: true }`.
     *
     * @param {String} src  - source path
     * @param {String} dest - destination path
     * @param {Object} options
     */
    static move(src: string, dest: string, options?: MoveOptions): Promise<void>;
    /**
     * Ensures that the directory exists. If the directory
     * structure does not exist, it is created.
     * Like `mkdir -p`.
     *
     * @param {String} dir - directory path
     *
     * @returns {String} dir - directory path
     */
    static ensureDir(dir: string): Promise<string>;
    /**
     * Removes a `dir` from the file system.The directory
     * can have content. Content in the directory will
     * be removed as well, like `rm -rf`.
     *
     * @param {String} dir - directory path
     */
    static removeDir(dir: string): Promise<void>;
    /**
     * Ensures that a directory is empty. Deletes directory
     * contents if the directory is not empty. If the
     * directory does not exist, it is created.
     * The directory itself is not deleted.
     *
     * @param {String} dir
     */
    static emptyDir(dir: string): Promise<void>;
    /**
     * Changes the permissions of a `file`.
     * The `mode` is a numeric bitmask and
     * can be an integer or string.
     *
     * @param {String} file
     * @param {String|Integer} mode
     */
    static chmod(file: string, mode: string): Promise<void>;
    /**
     * Ensures that the link from source to
     * destination exists. If the directory
     * structure does not exist, it is created.
     *
     * @param {String} src
     * @param {String} dest
     */
    static ensureLink(src: string, dest: string): Promise<void>;
    /**
     * Ensures that the symlink from source to
     * destination exists. If the directory
     * structure does not exist, it is created.
     *
     * @param {String} src
     * @param {String} dest
     * @param {String} type
     */
    static ensureSymlink(src: string, dest: string, type?: SymlinkType): Promise<void>;
    /**
     * Acquire a file lock on the specified `file` path with the given `options`.
     * If the `file` is already locked, this method won't throw an error and
     * instead just move on.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Function} release function
     */
    static lock(file: string, options?: LockOptions): Promise<void>;
    /**
     * Release an existent lock for the `file` and given `options`. If the `file`
     * isn't locked, this method won't throw an error and just move on.
     *
     * @param {String} file
     */
    static unlock(file: string, options?: UnlockOptions): Promise<void>;
    /**
     * Check if the `file` is locked and not stale.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Boolean}
     */
    static isLocked(file: string, options?: CheckOptions): Promise<boolean>;
    /**
     * Check if the `file` is not locked and not stale.
     *
     * @param {String} file
     * @param {Object} options
     *
     * @returns {Boolean}
     */
    static isNotLocked(file: string, options?: CheckOptions): Promise<boolean>;
    /**
     * Create a random temporary file path you can write to.
     * The operating system will clean up the temporary
     * files automatically, probably after some days.
     *
     * @param {Object} options
     *
     * @returns {String}
     */
    static tempFile(name?: string): Promise<string>;
    /**
     * Create a temporary directory path which will be cleaned up by the operating system.
     *
     * @returns {String}
     */
    static tempDir(): Promise<string>;
    /**
     * Returns the path to the user’s home directory. You may pass a `path` to which
     * the function should resolve in the user’s home directory. This method does
     * **not** ensure that the resolved path exists. Please do that yourself.
     *
     * @param {String} path
     *
     * @returns {String}
     */
    static homeDir(path?: string): Promise<string>;
    /**
     * Generates a random, temporary path on the filesystem.
     *
     * @returns {String}
     */
    static tempPath(): Promise<string>;
    /**
     * Returns the fully resolve, absolute file path to the given `path`.
     * Resolves any relative paths, like `..` or `.`, and symbolic links.
     *
     * @param {String} path
     * @param {Object} cache
     *
     * @returns {String}
     */
    static realPath(path: string, cache?: {
        [path: string]: string;
    }): Promise<string>;
    /**
     * Returns the extension of `file`. For example, returns `.html`
     * for the HTML file located at `/path/to/index.html`.
     *
     * @param {String} file
     *
     * @returns {String}
     */
    static extension(file: string): Promise<string>;
    /**
     * Returns the trailing name component from a file path. For example,
     * returns `file.png` from the path `/home/user/file.png`.
     *
     * @param {String} path
     * @param {String} extension
     *
     * @returns {String}
     */
    static basename(path: string, extension: string): Promise<string>;
    /**
     * Returns the file name without extension.
     *
     * @param {String} file
     *
     * @returns {String}
     */
    static filename(file: string): Promise<string>;
    /**
     * Returns the directory name of the given `path`.
     * For example, a file path of `foo/bar/baz/file.txt`
     * returns `foo/bar/baz`.
     *
     * @param {String} path
     *
     * @returns {String}
     */
    static dirname(path: string): Promise<string>;
    /**
     * Determines whether the given `path` is a file.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    static isFile(path: string): Promise<boolean>;
    /**
     * Determines whether the given `path` is a directory.
     *
     * @param {String} path
     *
     * @returns {Boolean}
     */
    static isDirectory(path: string): Promise<boolean>;
    /**
     * Append the given `content` to a `file`. This method
     * creates the `file` if it does not exist yet.
     *
     * @param {String|Buffer} file
     * @param {String|Buffer} content
     * @param {String|Object} options
     */
    static append(file: string | Buffer | number, content: string | Buffer, options?: AppendOptions): Promise<void>;
    /**
     * Rename a file located at `src` to the pathname defined by `dest`.
     * Both, `src` and `dest` must be file paths. If a file already
     * exists at the `dest` location, it will be overwritten.
     *
     * @param {String} src
     * @param {String} dest
     */
    static rename(src: string, dest: string): Promise<void>;
}
